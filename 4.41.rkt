#lang sicp
(#%require (file "./utils/zip.rkt"))
(#%require (file "./utils/filter.rkt"))
(#%require (file "./utils/flatmap.rkt"))

(define (cartesian-product xs ys)
  (flatmap (lambda (x)
             (if (pair? x)
                 (map (lambda (y) (append x (list y))) ys)
                 (map (lambda (y) (list x y)) ys)))
       xs))

(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))

(define (multiple-dwelling)
  (let ((cooper '(1 2 3 4 5))
        (miller '(1 2 3 4 5))
        (fletcher '(1 2 3 4 5))
        (smith '(1 2 3 4 5))
        (baker '(1 2 3 4 5))
        (res '()))
    (set! cooper (filter (lambda (x) (not (= x 1))) cooper))
    (set! res (cartesian-product cooper miller))
    (set! res (filter (lambda (xs) (> (cadr xs) (car xs))) res))
    (set! fletcher (filter (lambda (x) (not (= 5 x))) fletcher))
    (set! fletcher (filter (lambda (x) (not (= 1 x))) fletcher))
    (set! res (cartesian-product res fletcher))
    (set! res (filter (lambda (xs) (not (= 1 (abs (- (car xs) (caddr xs)))))) res))
    (set! res (cartesian-product res smith))
    (set! res (filter (lambda (xs) (not (= 1 (abs (- (caddr xs) (cadddr xs)))))) res))
    (set! baker (filter (lambda (x) (not (= 5 x))) baker))
    (set! res (cartesian-product res baker))
    (set! res (filter (lambda (xs) (distinct? xs)) res))
    (map (lambda (xs) (zip '(cooper miller fletcher smith baker) xs)) res)))

(multiple-dwelling)
