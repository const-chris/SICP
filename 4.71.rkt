#lang sicp
(#%require (file "./logic-evaluator.rkt"))

#|
Implementing simple query as

(define (simple-query query-pattern frame-stream)
  (stream-flatmap
    (lambda (frame)
      (stream-append
        (find-assertions query-pattern frame)
        (apply-rules query-pattern frame)))
    frame-stream))

would have the effect that (apply-rules query-pattern frame) would be evaluated before being passed to stream-append.
If the evaluating (apply-rules query-pattern frame) does not terminate (i.e. if the stream-car of the stream generated by apply-rules is a non-terminating computation), then the system will return no results rather than returning the results of (find-assertions query-pattern frame) before falling into the non-terminating computation.

A similar idea can be applied to explain the use of interleave-delayed and explictly delaying the second argument in disjoin.

One example that illustrates the difference in behavior here is the example of an infinite loop given in section 4.3:
|#

(run-query '(assert! (married Minnie Mickey)))

(run-query '(assert! (rule (married ?x ?y) (married ?y ?x))))

#| (run-query '(married Minnie ?who)) |#

#|
With explicit delay in simple query, the system will return

(married Minnie Mickey)
(married Minnie Mickey)
(married Minnie Mickey)
...

With the version of simple-query shown above, we will see no results printed.

Perhaps a better example of why postponing looping is useful is to consider how the results above might interact with filters (not or lisp-value).
Imagine we had the assertions above, as well as:
|#

(run-query '(assert! (job Mickey (Disney character))))

(run-query '(and (job ?x (Disney character))
                 (not (married Minnie ?x))))
#|
With explicit delay in simple-query, this terminates correctly with no results.
Since (find-assertions query-pattern frame) adds a frame to the stream passed to not before (apply-rules query-pattern frame) is evaluated, not immediately returns the empty-frame, and (apply-rules query-pattern frame), which is non-terminating, is never evaluated.

Conversely, without explicit delay, as shown above, the evaluation of the query does not terminate, because (apply-rules query-pattern frame) is evaluated before stream-append is called (i.e. before a non-empty stream can be passed to not).

It is worth noting that in this example if there were valid results, for instance if we had:

(run-query '(assert! (job Minnie (Disney character))))

the query will not terminate regardless of whether explicit delay is used.
|#
